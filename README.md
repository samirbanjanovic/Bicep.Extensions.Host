# Bicep.Extension.Host

The `Bicep.Extension.Host` project introduces a modern, .NET-native approach for building Bicep extensions. The handler framework has been redesigned to support **strongly typed handlers** and **type-based routing**, making extension development more robust and maintainable. Type specification is now generated directly through the service, enabling a seamless extension publishing experience.

## What's New

- **Strongly Typed Handlers**: Handlers are now registered as strongly typed classes. Routing of requests is based on the type received, ensuring type safety and reducing boilerplate.
- **Type-Based Routing**: The framework automatically routes incoming resource requests to the correct handler based on the resource type.
- **Service-Driven TypeSpec Generation**: Type metadata (TypeSpec) is generated by the service at runtime, simplifying the process of publishing and updating extensions.
- **.NET Standard Patterns**: Extensions use standard `WebApplicationBuilder` and DI container patterns.
- **No Wrappers**: You interact directly with the DI system and ASP.NET Core primitives.
- **Sample Implementation**: See [`Bicep.Extension.Sample`](src/Bicep.Extension.Sample/Program.cs) for a complete example.

## gRPC Server for Bicep Communication

This host starts a **gRPC server** to enable communication between Bicep and your extension. The server is configured using command-line arguments, which are passed through the `AddBicepExtensionHost(args)` function.

### Required Command-Line Arguments

All extension binaries are expected to accept the following CLI arguments:

- `--socket <socket_name>`: The path to the domain socket to connect on.
- `--pipe <pipe_name>`: The named pipe to connect on.
- `--http <port>`: The port to use for service. Default is 5000.
- `--wait-for-debugger`: Signals that you want to debug the extension, and that execution should pause until you are ready.

Once started (either via domain socket or named pipe), the extension:

- Exposes a gRPC endpoint over the relevant channel, adhering to the extension gRPC contract.
- Responds to `SIGTERM` to request a graceful shutdown.

## Handler Types

The handler framework now supports **strongly typed handlers** and **type-based routing**. You can implement one of the following handler interfaces:

- **`IResourceHandler<T>`**: A strongly typed handler for a specific resource type. This enables type-safe operations and reduces boilerplate by allowing you to work directly with your resource's .NET type.  
  Example: [`StronglyTypedHandler`](src/Bicep.Extension.Sample/Handlers/StronglyTypedHandler.cs) in the sample project implements `IResourceHandler<StronglyTypedResource>`.

- **`IResourceHandler`**: A generic, "catch all" handler that can process any resource. This is useful for scenarios where you need to handle multiple resource types in a single handler.  
  Example: [`OmniHandler`](src/Bicep.Extension.Sample/Handlers/OmniHandler.cs) in the sample project implements `IResourceHandler`.

> [!IMPORTANT]
> By design, you can only define one generic handler (`IResourceHandler`) per extension, but you can have multiple strongly typed handlers (`IResourceHandler<T>`) for different resource types. Each resource type may only be associated with one handler.

Routing is automatically performed based on the resource type received, ensuring requests are dispatched to the correct handler.

**Sample registration from [`Program.cs`](src/Bicep.Extension.Sample/Program.cs):**

```csharp
static async Task Main(string[] args)
{
    var builder = WebApplication
                        .CreateBuilder()
                        .AddBicepExtensionHost(args);

    builder.Services
           .AddBicepExtensionServices((factory, configurationType) => new TypeSettings(
               name: "ExtensionSample",
               version: "0.0.1",
               isSingleton: true,
               configurationType: new CrossFileTypeReference(
                                          "types.json"
                                        , factory.GetIndex(configurationType))))                   
           .AddBicepResourceHandler<OmniHandler>()
           .AddBicepResourceHandler<StronglyTypedHandler>()
           .AddSingleton<IBackendService, LocalOutputService>();

    var app = builder.Build();
    app.UseBicepDispatcher();

    await app.RunAsync();
}
```

- Register your handlers and services using the DI container.
- Use the `.AddBicepResourceHandler<T>()` IServiceCollection extension method to register your handler. This method validates that only a single generic handler is registered and that there's only one resource handler per resource type.
- TypeSpec is generated automatically by the service for your registered types.
- Build and run your app as you would with any ASP.NET Core application.

For more details, see the sample implementation in [src/Bicep.Extension.Sample/Program.cs](src/Bicep.Extension.Sample/Program.cs).

## Testing

You can test your extension's gRPC endpoints using tools like [`grpcurl`](https://github.com/fullstorydev/grpcurl) and [`grpcui`](https://github.com/fullstorydev/grpcui).

- **grpcurl**: A command-line tool for interacting with gRPC servers.
- **grpcui**: A web-based UI for gRPC services, similar to Swagger UI for REST APIs.

### Example grpcurl Request

To test the `CreateOrUpdate` method for a strongly typed resource, you can use the following command:

> [!NOTE]
> This will invoke the associated resource type handler,`StronglyTypedResourceHandler`, as it's mapped to `StronglyTypedResource` type

```sh
grpcurl -plaintext -d '{"type": "StronglyTypedResource", "apiVersion": "0.0.1", "properties": "{\"name\":\"sample\",\"actionType\":\"fetch\"}"}' localhost:5000 extension.BicepExtension/CreateOrUpdate
```

> [!NOTE]
> This will invoke the generic resource handler, `OmniHandler`, since there's no associated resource handler for type `GenericResource`

```sh
grpcurl -plaintext -d '{"type": "GenericResource", "apiVersion": "0.0.1", "properties": "{\"name\":\"sample\",\"actionType\":\"fetch\"}"}' localhost:5000 extension.BicepExtension/CreateOrUpdate
```

- `-plaintext`: Connect without TLS (for local development).
- `-d`: The request payload in JSON format.
- `localhost:5000`: The address and port where your extension is running.
- `extension.BicepExtension/CreateOrUpdate`: The fully qualified gRPC method name.

### Using grpcui

To launch a web UI for your gRPC service, run:

```sh
grpcui -plaintext localhost:5005
```

This will open a browser window where you can interactively explore and invoke your extension's gRPC endpoints.

---
For more information, see the sample implementation in [src/Bicep.Extension.Sample/Program.cs](src/Bicep.Extension.Sample/Program.cs).
